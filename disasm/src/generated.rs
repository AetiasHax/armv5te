#![cfg_attr(rustfmt, rustfmt_skip)]
// Generated by armv5te-generator. Do not edit!
///This lookup table limits the search to at most 7 opcodes by reading 6 pre-selected bits from the instruction.
static LOOKUP_TABLE: [(u8, u8); 64] = [
    (0, 7),
    (7, 14),
    (14, 18),
    (18, 23),
    (23, 26),
    (26, 27),
    (27, 29),
    (0, 0),
    (29, 33),
    (0, 0),
    (33, 37),
    (0, 0),
    (37, 39),
    (0, 0),
    (39, 41),
    (0, 0),
    (41, 42),
    (42, 43),
    (0, 0),
    (0, 0),
    (43, 44),
    (44, 45),
    (0, 0),
    (0, 0),
    (45, 46),
    (46, 47),
    (0, 0),
    (0, 0),
    (47, 48),
    (48, 49),
    (0, 0),
    (0, 0),
    (49, 53),
    (53, 55),
    (55, 56),
    (0, 0),
    (56, 60),
    (60, 64),
    (64, 65),
    (0, 0),
    (65, 66),
    (66, 68),
    (68, 70),
    (0, 0),
    (70, 71),
    (71, 73),
    (73, 74),
    (0, 0),
    (74, 75),
    (0, 0),
    (0, 0),
    (0, 0),
    (75, 76),
    (0, 0),
    (0, 0),
    (0, 0),
    (76, 77),
    (0, 0),
    (0, 0),
    (0, 0),
    (77, 78),
    (0, 0),
    (0, 0),
    (0, 0),
];
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
#[non_exhaustive]
pub enum Opcode {
    /// Illegal or unknown
    #[default]
    Illegal = u8::MAX,
    /// AND: Bitwise AND
    And = 0,
    /// B: Branch
    B = 1,
    /// BLX: Branch and Link and Exchange to Thumb (immediate target)
    BlxI = 2,
    /// STR: Store Register
    Str = 3,
    /// CDP: Coprocessor Data Processing
    Cdp = 4,
    /// STM: Store Multiple
    Stm = 5,
    /// STC: Store Coprocessor
    Stc = 6,
    /// MCR2: Move to Coprocessor from ARM Register (unconditional, extended)
    Mcr2 = 7,
    /// MCR: Move to Coprocessor from ARM Register
    Mcr = 8,
    /// STRH: Store Register Halfword
    Strh = 9,
    /// STRD: Store Registers Doubleword
    Strd = 10,
    /// LDRD: Load Registers Doubleword
    Ldrd = 11,
    /// CDP2: Coprocessor Data Processing (unconditional, extended)
    Cdp2 = 12,
    /// MUL: Multiply
    Mul = 13,
    /// LDM: Load Multiple
    Ldm = 14,
    /// LDR: Load Register
    Ldr = 15,
    /// LDC: Load Coprocessor
    Ldc = 16,
    /// LDC2: Load Coprocessor (unconditional, extended)
    Ldc2 = 17,
    /// MRC: Move to ARM Register from Coprocessor
    Mrc = 18,
    /// MRC2: Move to ARM Register from Coprocessor (unconditional, extended)
    Mrc2 = 19,
    /// LDRH: Load Register Halfword
    Ldrh = 20,
    /// LDRSB: Load Register Signed Byte
    Ldrsb = 21,
    /// LDRSH: Load Register Signed Halfword
    Ldrsh = 22,
    /// EOR: Bitwise Exclusive OR
    Eor = 23,
    /// STM: Store Multiple (writeback)
    StmW = 24,
    /// STRT: Store Register with Translation
    Strt = 25,
    /// MLA: Multiply Accumulate
    Mla = 26,
    /// LDM: Load Multiple (writeback)
    LdmW = 27,
    /// LDRT: Load Register with Translation
    Ldrt = 28,
    /// SUB: Subtract
    Sub = 29,
    /// MCRR: Move to Coprocessor from two ARM Registers
    Mcrr = 30,
    /// STM: Store Multiple (privileged)
    StmP = 31,
    /// STRB: Store Register Byte
    Strb = 32,
    /// MRRC: Move to two ARM Registers from Coprocessor
    Mrrc = 33,
    /// LDRB: Load Register Byte
    Ldrb = 34,
    /// LDM: Load Multiple (including PC)
    LdmPc = 35,
    /// LDM: Load Multiple (privileged)
    LdmP = 36,
    /// STRBT: Store Register Byte with Translation
    Strbt = 37,
    /// RSB: Reverse Subtract
    Rsb = 38,
    /// LDM: Load Multiple (including PC, writeback)
    LdmPcW = 39,
    /// LDRBT: Load Register Byte with Translation
    Ldrbt = 40,
    /// ADD: Add
    Add = 41,
    /// UMULL: Unsigned Multiply Long
    Umull = 42,
    /// ADC: Add with Carry
    Adc = 43,
    /// UMLAL: Unsigned Multiply Accumulate Long
    Umlal = 44,
    /// SBC: Subtract with Carry
    Sbc = 45,
    /// SMULL: Signed Multiply Long
    Smull = 46,
    /// RSC: Reverse Subtract with Carry
    Rsc = 47,
    /// SMLAL: Signed Multiply Accumulate Long
    SmlalC = 48,
    /// SMLA: Signed Multiply Accumulate
    Smla = 49,
    /// MRS: Move to ARM Register from Status Register
    Mrs = 50,
    /// SWI: Software Interrupt
    Swi = 51,
    /// BL: Branch and Link
    Bl = 52,
    /// QADD: Saturating Add
    Qadd = 53,
    /// SWP: Swap
    Swp = 54,
    /// TEST: Test
    Test = 55,
    /// MSR: Move to Status Register from ARM Register
    MsrI = 56,
    /// SMLAW: Signed Multiply Accumulate Word
    Smlaw = 57,
    /// SMULW: Signed Multiply Word
    Smulw = 58,
    /// MSR: Move to Status Register from ARM Register
    Msr = 59,
    /// BLX: Branch and Link and Exchange to Thumb (register target)
    BlxR = 60,
    /// BX: Branch and Exchange to Thumb
    Bx = 61,
    /// BKPT: Breakpoint
    Bkpt = 62,
    /// QSUB: Saturating Subtract
    Qsub = 63,
    /// TEQ: Test Equivalence
    Teq = 64,
    /// SMLAL: Signed Multiply Accumulate Long
    SmlalXy = 65,
    /// QDADD: Saturating Double and Add
    Qdadd = 66,
    /// SWPB: Swap Byte
    Swpb = 67,
    /// CMP: Compare
    Cmp = 68,
    /// PLD: Preload Data
    Pld = 69,
    /// SMUL: Signed Multiply
    Smul = 70,
    /// CLZ: Count Leading Zeros
    Clz = 71,
    /// QDSUB: Saturating Double and Subtract
    Qdsub = 72,
    /// CMN: Compare Negative
    Cmn = 73,
    /// ORR: Logical OR
    Orr = 74,
    /// MOV: Move
    Mov = 75,
    /// BIC: Bit Clear
    Bic = 76,
    /// MVN: Move Not
    Mvn = 77,
}
