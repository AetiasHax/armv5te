#![cfg_attr(rustfmt, rustfmt_skip)]
// Generated by armv5te-generator. Do not edit!
use crate::disasm::Ins;
/// This lookup table limits the search to at most 5 opcodes by reading 6 pre-selected bits from the instruction.
static LOOKUP_TABLE: [(u8, u8); 64] = [
    (0, 5),
    (5, 10),
    (10, 11),
    (11, 14),
    (14, 17),
    (17, 19),
    (19, 20),
    (0, 0),
    (20, 23),
    (23, 24),
    (24, 26),
    (0, 0),
    (26, 28),
    (28, 29),
    (29, 30),
    (0, 0),
    (30, 34),
    (34, 36),
    (36, 37),
    (0, 0),
    (37, 42),
    (42, 46),
    (46, 47),
    (0, 0),
    (47, 49),
    (49, 51),
    (51, 52),
    (0, 0),
    (52, 54),
    (54, 56),
    (56, 57),
    (0, 0),
    (57, 60),
    (60, 63),
    (63, 66),
    (66, 68),
    (68, 69),
    (0, 0),
    (69, 70),
    (0, 0),
    (70, 72),
    (0, 0),
    (72, 74),
    (0, 0),
    (74, 75),
    (0, 0),
    (75, 76),
    (0, 0),
    (76, 77),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (77, 78),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
    (0, 0),
];
/// These tuples contain a bitmask and pattern for each opcode.
static OPCODE_PATTERNS: [(u32, u32); 78] = [
    // BLX: Branch and Link and Exchange to Thumb (immediate target)
    (0xfe000000, 0xfa000000),
    // ADD: Add
    (0x0de00000, 0x00800000),
    // AND: Bitwise AND
    (0x0de00000, 0x00000000),
    // STM: Store Multiple
    (0x0e700000, 0x08000000),
    // B: Branch
    (0x0f000000, 0x0a000000),
    // MUL: Multiply
    (0x0fe0f0f0, 0x00000090),
    // UMULL: Unsigned Multiply Long
    (0x0fe000f0, 0x00800090),
    // LDRD: Load Registers Doubleword
    (0x0e1000f0, 0x000000d0),
    // STRD: Store Registers Doubleword
    (0x0e1000f0, 0x000000f0),
    // STRH: Store Register Halfword
    (0x0e1000f0, 0x000000b0),
    // LDM: Load Multiple
    (0x0e700000, 0x08100000),
    // LDRH: Load Register Halfword
    (0x0e1000f0, 0x001000b0),
    // LDRSB: Load Register Signed Byte
    (0x0e1000f0, 0x001000d0),
    // LDRSH: Load Register Signed Halfword
    (0x0e1000f0, 0x001000f0),
    // ADC: Add with Carry
    (0x0de00000, 0x00a00000),
    // EOR: Bitwise Exclusive OR
    (0x0de00000, 0x00200000),
    // STM: Store Multiple (writeback)
    (0x0e700000, 0x08200000),
    // MLA: Multiply Accumulate
    (0x0fe000f0, 0x00200090),
    // UMLAL: Unsigned Multiply Accumulate Long
    (0x0fe000f0, 0x00a00090),
    // LDM: Load Multiple (writeback)
    (0x0e700000, 0x08300000),
    // SBC: Subtract with Carry
    (0x0de00000, 0x00c00000),
    // STM: Store Multiple (privileged)
    (0x0e700000, 0x08400000),
    // SUB: Subtract
    (0x0de00000, 0x00400000),
    // SMULL: Signed Multiply Long
    (0x0fe000f0, 0x00c00090),
    // LDM: Load Multiple (privileged)
    (0x0e708000, 0x08500000),
    // LDM: Load Multiple (including PC)
    (0x0e708000, 0x08508000),
    // RSB: Reverse Subtract
    (0x0de00000, 0x00600000),
    // RSC: Reverse Subtract with Carry
    (0x0de00000, 0x00e00000),
    // SMLAL: Signed Multiply Accumulate Long
    (0x0fe000f0, 0x00e00090),
    // LDM: Load Multiple (including PC, writeback)
    (0x0e708000, 0x08708000),
    // MRS: Move to ARM Register from Status Register
    (0x0fbf0fff, 0x010f0000),
    // SMLA: Signed Multiply Accumulate
    (0x0ff00090, 0x01000080),
    // ORR: Logical OR
    (0x0de00000, 0x01800000),
    // BL: Branch and Link
    (0x0f000000, 0x0b000000),
    // QADD: Saturating Add
    (0x0ff00ff0, 0x01000050),
    // SWP: Swap
    (0x0ff00ff0, 0x01000090),
    // TEST: Test
    (0x0df0f000, 0x01100000),
    // MSR: Move to Status Register from ARM Register
    (0x0fb0fff0, 0x0120f000),
    // SMULW: Signed Multiply Word
    (0x0ff0f0b0, 0x012000a0),
    // MSR: Move to Status Register from ARM Register
    (0x0fb0f000, 0x0320f000),
    // SMLAW: Signed Multiply Accumulate Word
    (0x0ff000b0, 0x01200080),
    // MOV: Move
    (0x0def0000, 0x01a00000),
    // BLX: Branch and Link and Exchange to Thumb (register target)
    (0x0ffffff0, 0x012fff30),
    // BX: Branch and Exchange to Thumb
    (0x0ffffff0, 0x012fff10),
    // BKPT: Breakpoint
    (0xfff000f0, 0xe1200070),
    // QSUB: Saturating Subtract
    (0x0ff00ff0, 0x01200050),
    // TEQ: Test Equivalence
    (0x0df0f000, 0x01300000),
    // SMLAL: Signed Multiply Accumulate Long
    (0x0ff00090, 0x01400080),
    // BIC: Bit Clear
    (0x0de00000, 0x01c00000),
    // QDADD: Saturating Double and Add
    (0x0ff00ff0, 0x01400050),
    // SWPB: Swap Byte
    (0x0ff00ff0, 0x01400090),
    // CMP: Compare
    (0x0df0f000, 0x01500000),
    // SMUL: Signed Multiply
    (0x0ff0f090, 0x01600080),
    // MVN: Move Not
    (0x0def0000, 0x01e00000),
    // CLZ: Count Leading Zeros
    (0x0fff0ff0, 0x016f0f10),
    // QDSUB: Saturating Double and Subtract
    (0x0ff00ff0, 0x01600050),
    // CMN: Compare Negative
    (0x0df0f000, 0x01700000),
    // CDP: Coprocessor Data Processing
    (0x0f000010, 0x0e000000),
    // STC: Store Coprocessor
    (0x0e100000, 0x0c000000),
    // STR: Store Register
    (0x0c500000, 0x04000000),
    // MCR2: Move to Coprocessor from ARM Register (unconditional, extended)
    (0xff100010, 0xfe000010),
    // CDP2: Coprocessor Data Processing (unconditional, extended)
    (0xff000010, 0xfe000010),
    // MCR: Move to Coprocessor from ARM Register
    (0x0f100010, 0x0e000010),
    // LDC2: Load Coprocessor (unconditional, extended)
    (0xfe100000, 0xfc100000),
    // LDC: Load Coprocessor
    (0x0e100000, 0x0c100000),
    // LDR: Load Register
    (0x0c500000, 0x04100000),
    // MRC2: Move to ARM Register from Coprocessor (unconditional, extended)
    (0xff100010, 0xfe100010),
    // MRC: Move to ARM Register from Coprocessor
    (0x0f100010, 0x0e100010),
    // STRT: Store Register with Translation
    (0x0d700000, 0x04200000),
    // LDRT: Load Register with Translation
    (0x0d700000, 0x04300000),
    // MCRR: Move to Coprocessor from two ARM Registers
    (0x0ff00000, 0x0c400000),
    // STRB: Store Register Byte
    (0x0c500000, 0x04400000),
    // MRRC: Move to two ARM Registers from Coprocessor
    (0x0ff00000, 0x0c500000),
    // LDRB: Load Register Byte
    (0x0c500000, 0x04500000),
    // STRBT: Store Register Byte with Translation
    (0x0d700000, 0x04600000),
    // LDRBT: Load Register Byte with Translation
    (0x0d700000, 0x04700000),
    // SWI: Software Interrupt
    (0x0f000000, 0x0f000000),
    // PLD: Preload Data
    (0xfd70f000, 0xf550f000),
];
/// These are the mnemonics of each opcode. Some mnemonics are duplicated due to them having multiple formats.
static OPCODE_MNEMONICS: [&str; 78] = [
    "blx",
    "add",
    "and",
    "stm",
    "b",
    "mul",
    "umull",
    "ldrd",
    "strd",
    "strh",
    "ldm",
    "ldrh",
    "ldrsb",
    "ldrsh",
    "adc",
    "eor",
    "stm",
    "mla",
    "umlal",
    "ldm",
    "sbc",
    "stm",
    "sub",
    "smull",
    "ldm",
    "ldm",
    "rsb",
    "rsc",
    "smlal",
    "ldm",
    "mrs",
    "smla",
    "orr",
    "bl",
    "qadd",
    "swp",
    "test",
    "msr",
    "smulw",
    "msr",
    "smlaw",
    "mov",
    "blx",
    "bx",
    "bkpt",
    "qsub",
    "teq",
    "smlal",
    "bic",
    "qdadd",
    "swpb",
    "cmp",
    "smul",
    "mvn",
    "clz",
    "qdsub",
    "cmn",
    "cdp",
    "stc",
    "str",
    "mcr2",
    "cdp2",
    "mcr",
    "ldc2",
    "ldc",
    "ldr",
    "mrc2",
    "mrc",
    "strt",
    "ldrt",
    "mcrr",
    "strb",
    "mrrc",
    "ldrb",
    "strbt",
    "ldrbt",
    "swi",
    "pld",
];
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
#[non_exhaustive]
pub enum Opcode {
    /// Illegal or unknown
    #[default]
    Illegal = u8::MAX,
    /// BLX: Branch and Link and Exchange to Thumb (immediate target)
    BlxI = 0,
    /// ADD: Add
    Add = 1,
    /// AND: Bitwise AND
    And = 2,
    /// STM: Store Multiple
    Stm = 3,
    /// B: Branch
    B = 4,
    /// MUL: Multiply
    Mul = 5,
    /// UMULL: Unsigned Multiply Long
    Umull = 6,
    /// LDRD: Load Registers Doubleword
    Ldrd = 7,
    /// STRD: Store Registers Doubleword
    Strd = 8,
    /// STRH: Store Register Halfword
    Strh = 9,
    /// LDM: Load Multiple
    Ldm = 10,
    /// LDRH: Load Register Halfword
    Ldrh = 11,
    /// LDRSB: Load Register Signed Byte
    Ldrsb = 12,
    /// LDRSH: Load Register Signed Halfword
    Ldrsh = 13,
    /// ADC: Add with Carry
    Adc = 14,
    /// EOR: Bitwise Exclusive OR
    Eor = 15,
    /// STM: Store Multiple (writeback)
    StmW = 16,
    /// MLA: Multiply Accumulate
    Mla = 17,
    /// UMLAL: Unsigned Multiply Accumulate Long
    Umlal = 18,
    /// LDM: Load Multiple (writeback)
    LdmW = 19,
    /// SBC: Subtract with Carry
    Sbc = 20,
    /// STM: Store Multiple (privileged)
    StmP = 21,
    /// SUB: Subtract
    Sub = 22,
    /// SMULL: Signed Multiply Long
    Smull = 23,
    /// LDM: Load Multiple (privileged)
    LdmP = 24,
    /// LDM: Load Multiple (including PC)
    LdmPc = 25,
    /// RSB: Reverse Subtract
    Rsb = 26,
    /// RSC: Reverse Subtract with Carry
    Rsc = 27,
    /// SMLAL: Signed Multiply Accumulate Long
    SmlalC = 28,
    /// LDM: Load Multiple (including PC, writeback)
    LdmPcW = 29,
    /// MRS: Move to ARM Register from Status Register
    Mrs = 30,
    /// SMLA: Signed Multiply Accumulate
    Smla = 31,
    /// ORR: Logical OR
    Orr = 32,
    /// BL: Branch and Link
    Bl = 33,
    /// QADD: Saturating Add
    Qadd = 34,
    /// SWP: Swap
    Swp = 35,
    /// TEST: Test
    Test = 36,
    /// MSR: Move to Status Register from ARM Register
    Msr = 37,
    /// SMULW: Signed Multiply Word
    Smulw = 38,
    /// MSR: Move to Status Register from ARM Register
    MsrI = 39,
    /// SMLAW: Signed Multiply Accumulate Word
    Smlaw = 40,
    /// MOV: Move
    Mov = 41,
    /// BLX: Branch and Link and Exchange to Thumb (register target)
    BlxR = 42,
    /// BX: Branch and Exchange to Thumb
    Bx = 43,
    /// BKPT: Breakpoint
    Bkpt = 44,
    /// QSUB: Saturating Subtract
    Qsub = 45,
    /// TEQ: Test Equivalence
    Teq = 46,
    /// SMLAL: Signed Multiply Accumulate Long
    SmlalXy = 47,
    /// BIC: Bit Clear
    Bic = 48,
    /// QDADD: Saturating Double and Add
    Qdadd = 49,
    /// SWPB: Swap Byte
    Swpb = 50,
    /// CMP: Compare
    Cmp = 51,
    /// SMUL: Signed Multiply
    Smul = 52,
    /// MVN: Move Not
    Mvn = 53,
    /// CLZ: Count Leading Zeros
    Clz = 54,
    /// QDSUB: Saturating Double and Subtract
    Qdsub = 55,
    /// CMN: Compare Negative
    Cmn = 56,
    /// CDP: Coprocessor Data Processing
    Cdp = 57,
    /// STC: Store Coprocessor
    Stc = 58,
    /// STR: Store Register
    Str = 59,
    /// MCR2: Move to Coprocessor from ARM Register (unconditional, extended)
    Mcr2 = 60,
    /// CDP2: Coprocessor Data Processing (unconditional, extended)
    Cdp2 = 61,
    /// MCR: Move to Coprocessor from ARM Register
    Mcr = 62,
    /// LDC2: Load Coprocessor (unconditional, extended)
    Ldc2 = 63,
    /// LDC: Load Coprocessor
    Ldc = 64,
    /// LDR: Load Register
    Ldr = 65,
    /// MRC2: Move to ARM Register from Coprocessor (unconditional, extended)
    Mrc2 = 66,
    /// MRC: Move to ARM Register from Coprocessor
    Mrc = 67,
    /// STRT: Store Register with Translation
    Strt = 68,
    /// LDRT: Load Register with Translation
    Ldrt = 69,
    /// MCRR: Move to Coprocessor from two ARM Registers
    Mcrr = 70,
    /// STRB: Store Register Byte
    Strb = 71,
    /// MRRC: Move to two ARM Registers from Coprocessor
    Mrrc = 72,
    /// LDRB: Load Register Byte
    Ldrb = 73,
    /// STRBT: Store Register Byte with Translation
    Strbt = 74,
    /// LDRBT: Load Register Byte with Translation
    Ldrbt = 75,
    /// SWI: Software Interrupt
    Swi = 76,
    /// PLD: Preload Data
    Pld = 77,
}
impl Opcode {
    #[inline]
    pub fn find(code: u32) -> Self {
        let index = bucket_index(code);
        let lookup = LOOKUP_TABLE[index];
        if lookup.0 == lookup.1 {
            return Self::Illegal;
        }
        for i in lookup.0..lookup.1 {
            let (bitmask, pattern) = OPCODE_PATTERNS[i as usize];
            if (code & bitmask) == pattern {
                return unsafe { core::mem::transmute::<u8, Opcode>(i) };
            }
        }
        Self::Illegal
    }
    pub fn mnemonic(self) -> &'static str {
        OPCODE_MNEMONICS[self as usize]
    }
    pub fn count() -> usize {
        78
    }
}
impl Ins {
    /// cond: Condition Code
    #[inline(always)]
    pub const fn field_cond(&self) -> u8 {
        ((self.code & 0xf0000000) >> 28) as u8
    }
    /// Rn: First source operand register
    #[inline(always)]
    pub const fn field_rn(&self) -> u8 {
        ((self.code & 0x000f0000) >> 16) as u8
    }
    /// Rm: Second source operand register
    #[inline(always)]
    pub const fn field_rm(&self) -> u8 {
        (self.code & 0x0000000f) as u8
    }
    /// Rd: Destination register
    #[inline(always)]
    pub const fn field_rd(&self) -> u8 {
        ((self.code & 0x0000f000) >> 12) as u8
    }
    /// Rs: Register containing shift offset
    #[inline(always)]
    pub const fn field_rs(&self) -> u8 {
        ((self.code & 0x00000f00) >> 8) as u8
    }
    /// RdHi: Upper 32-bit long destination register
    #[inline(always)]
    pub const fn field_rdhi(&self) -> u8 {
        ((self.code & 0x000f0000) >> 16) as u8
    }
    /// RdLo: Lower 32-bit long destination register
    #[inline(always)]
    pub const fn field_rdlo(&self) -> u8 {
        ((self.code & 0x0000f000) >> 12) as u8
    }
    /// register_list: List of registers
    #[inline(always)]
    pub const fn field_register_list(&self) -> u16 {
        (self.code & 0x0000ffff) as u16
    }
    /// register_list_15: List of registers, except PC
    #[inline(always)]
    pub const fn field_register_list_15(&self) -> u16 {
        (self.code & 0x00007fff) as u16
    }
    /// CRn: First source coprocessor register
    #[inline(always)]
    pub const fn field_crn(&self) -> u8 {
        ((self.code & 0x000f0000) >> 16) as u8
    }
    /// CRm: Second source coprocessor register
    #[inline(always)]
    pub const fn field_crm(&self) -> u8 {
        (self.code & 0x0000000f) as u8
    }
    /// CRd: Destination coprocessor register
    #[inline(always)]
    pub const fn field_crd(&self) -> u8 {
        ((self.code & 0x0000f000) >> 12) as u8
    }
    /// W: Write back to base register
    #[inline(always)]
    pub const fn field_w(&self) -> bool {
        ((self.code & 0x00200000) >> 21) != 0
    }
    /// rotate_imm: Immediate rotate offset
    #[inline(always)]
    pub const fn field_rotate_imm(&self) -> u8 {
        ((self.code & 0x00000f00) >> 8) as u8
    }
    /// immed_8: 8-bit immediate
    #[inline(always)]
    pub const fn field_immed_8(&self) -> u8 {
        (self.code & 0x000000ff) as u8
    }
    /// immed_24: 24-bit immediate
    #[inline(always)]
    pub const fn field_immed_24(&self) -> u32 {
        (self.code & 0x00ffffff) as u32
    }
    /// immedH: High nibble immediate
    #[inline(always)]
    pub const fn field_immedh(&self) -> u8 {
        ((self.code & 0x00000f00) >> 8) as u8
    }
    /// immedL: Low nibble immediate
    #[inline(always)]
    pub const fn field_immedl(&self) -> u8 {
        (self.code & 0x0000000f) as u8
    }
    /// shift_imm: Immediate shift offset
    #[inline(always)]
    pub const fn field_shift_imm(&self) -> u8 {
        ((self.code & 0x00000f80) >> 7) as u8
    }
    /// shift: Type of shift operation
    #[inline(always)]
    pub const fn field_shift(&self) -> u8 {
        ((self.code & 0x00000060) >> 5) as u8
    }
    /// U: Add (1) or subtract (0)
    #[inline(always)]
    pub const fn field_u(&self) -> bool {
        ((self.code & 0x00800000) >> 23) != 0
    }
    /// B: Byte (1) or word (0)
    #[inline(always)]
    pub const fn field_b(&self) -> bool {
        ((self.code & 0x00400000) >> 22) != 0
    }
    /// R: Move SPSR (1) or CPSR (0)
    #[inline(always)]
    pub const fn field_r(&self) -> bool {
        ((self.code & 0x00400000) >> 22) != 0
    }
    /// offset_8: 8-bit immediate offset
    #[inline(always)]
    pub const fn field_offset_8(&self) -> u8 {
        (self.code & 0x000000ff) as u8
    }
    /// offset_12: 12-bit immediate offset
    #[inline(always)]
    pub const fn field_offset_12(&self) -> u16 {
        (self.code & 0x00000fff) as u16
    }
    /// option: Additional instruction options for coprocessor
    #[inline(always)]
    pub const fn field_option(&self) -> u8 {
        (self.code & 0x000000ff) as u8
    }
    /// H: Add 2 to BLX target address
    #[inline(always)]
    pub const fn field_h(&self) -> bool {
        ((self.code & 0x01000000) >> 24) != 0
    }
    /// signed_immed_24: Signed 24-bit immediate
    #[inline(always)]
    pub const fn field_signed_immed_24(&self) -> u32 {
        (self.code & 0x00ffffff) as u32
    }
    /// immed_8_20: 12-bit immediate in bits 8..20
    #[inline(always)]
    pub const fn field_immed_8_20(&self) -> u16 {
        ((self.code & 0x000fff00) >> 8) as u16
    }
    /// immed_0_4: 4-bit immediate in bits 0..4
    #[inline(always)]
    pub const fn field_immed_0_4(&self) -> u8 {
        (self.code & 0x0000000f) as u8
    }
    /// field_mask: Status fields to set
    #[inline(always)]
    pub const fn field_field_mask(&self) -> u8 {
        ((self.code & 0x000f0000) >> 16) as u8
    }
    /// opcode: Coprocessor operation to perform (user-defined)
    #[inline(always)]
    pub const fn field_opcode(&self) -> u8 {
        ((self.code & 0x000000f0) >> 4) as u8
    }
    /// codat_opcode_1: Coprocessor operation to perform (user-defined, used by CDP instruction)
    #[inline(always)]
    pub const fn field_codat_opcode_1(&self) -> u8 {
        ((self.code & 0x00f00000) >> 20) as u8
    }
    /// comov_opcode_1: Coprocessor operation to perform (user-defined, used by MCR/MRC instructions)
    #[inline(always)]
    pub const fn field_comov_opcode_1(&self) -> u8 {
        ((self.code & 0x00e00000) >> 21) as u8
    }
    /// opcode_2: Coprocessor operation to perform (user-defined)
    #[inline(always)]
    pub const fn field_opcode_2(&self) -> u8 {
        ((self.code & 0x000000e0) >> 5) as u8
    }
    /// cp_num: Coprocessor number
    #[inline(always)]
    pub const fn field_cp_num(&self) -> u8 {
        ((self.code & 0x00000f00) >> 8) as u8
    }
    /// S: Update condition status flags
    pub const fn modifier_s(&self) -> bool {
        (self.code & 0x00100000) == 0x00100000
    }
    /// L: Long coprocessor load (e.g. double instead of float)
    pub const fn modifier_l(&self) -> bool {
        (self.code & 0x00400000) == 0x00400000
    }
    /// y: Second multiply operand in bottom (0) or top (1) half
    pub const fn modifier_y(&self) -> bool {
        (self.code & 0x00000040) == 0x00000040
    }
    /// x: First multiply operand in bottom (0) or top (1) half
    pub const fn modifier_x(&self) -> bool {
        (self.code & 0x00000020) == 0x00000020
    }
    /// cond: Condition code
    pub const fn modifier_cond(&self) -> Cond {
        match self.code & 0xf0000000 {
            0x00000000 => Cond::Eq,
            0x10000000 => Cond::Ne,
            0x20000000 => Cond::Hs,
            0x30000000 => Cond::Lo,
            0x40000000 => Cond::Mi,
            0x50000000 => Cond::Pl,
            0x60000000 => Cond::Vs,
            0x70000000 => Cond::Vc,
            0x80000000 => Cond::Hi,
            0x90000000 => Cond::Ls,
            0xa0000000 => Cond::Ge,
            0xb0000000 => Cond::Lt,
            0xc0000000 => Cond::Gt,
            0xd0000000 => Cond::Le,
            0xe0000000 => Cond::Al,
            _ => unreachable!(),
        }
    }
    /// addr_data: Data-processing operands
    pub const fn modifier_addr_data(&self) -> AddrData {
        if (self.code & 0x0e000ff0) == 0x00000000 {
            AddrData::Reg
        } else if (self.code & 0x0e000ff0) == 0x00000060 {
            AddrData::Rrx
        } else if (self.code & 0x0e0000f0) == 0x00000010 {
            AddrData::LslReg
        } else if (self.code & 0x0e0000f0) == 0x00000030 {
            AddrData::LsrReg
        } else if (self.code & 0x0e0000f0) == 0x00000050 {
            AddrData::AsrReg
        } else if (self.code & 0x0e0000f0) == 0x00000070 {
            AddrData::RorReg
        } else if (self.code & 0x0e000070) == 0x00000000 {
            AddrData::LslImm
        } else if (self.code & 0x0e000070) == 0x00000020 {
            AddrData::LsrImm
        } else if (self.code & 0x0e000070) == 0x00000040 {
            AddrData::AsrImm
        } else if (self.code & 0x0e000070) == 0x00000060 {
            AddrData::RorImm
        } else if (self.code & 0x0e000000) == 0x02000000 {
            AddrData::Imm
        } else {
            unreachable!()
        }
    }
    /// addr_ldr_str: Load and Store Word or Unsigned Byte
    pub const fn modifier_addr_ldr_str(&self) -> AddrLdrStr {
        if (self.code & 0x0f200ff0) == 0x07000000 {
            AddrLdrStr::Reg
        } else if (self.code & 0x0f200ff0) == 0x07200000 {
            AddrLdrStr::RegPre
        } else if (self.code & 0x0f200ff0) == 0x06000000 {
            AddrLdrStr::RegPost
        } else if (self.code & 0x0f200010) == 0x07000000 {
            AddrLdrStr::Scl
        } else if (self.code & 0x0f200010) == 0x07200000 {
            AddrLdrStr::SclPre
        } else if (self.code & 0x0f200010) == 0x06000000 {
            AddrLdrStr::SclPost
        } else if (self.code & 0x0f200000) == 0x05000000 {
            AddrLdrStr::Imm
        } else if (self.code & 0x0f200000) == 0x05200000 {
            AddrLdrStr::ImmPre
        } else if (self.code & 0x0f200000) == 0x04000000 {
            AddrLdrStr::ImmPost
        } else {
            unreachable!()
        }
    }
    /// addr_misc_ldr_str: Miscellaneous Loads and Stores
    pub const fn modifier_addr_misc_ldr_str(&self) -> AddrMiscLdrStr {
        if (self.code & 0x0f600f90) == 0x01000090 {
            AddrMiscLdrStr::Reg
        } else if (self.code & 0x0f600f90) == 0x01200090 {
            AddrMiscLdrStr::RegPre
        } else if (self.code & 0x0f600f90) == 0x00000090 {
            AddrMiscLdrStr::RegPost
        } else if (self.code & 0x0f600090) == 0x01400090 {
            AddrMiscLdrStr::Imm
        } else if (self.code & 0x0f600090) == 0x01600090 {
            AddrMiscLdrStr::ImmPre
        } else if (self.code & 0x0f600090) == 0x00400090 {
            AddrMiscLdrStr::ImmPost
        } else {
            unreachable!()
        }
    }
    /// addr_ldm_stm: Load and Store Multiple
    pub const fn modifier_addr_ldm_stm(&self) -> AddrLdmStm {
        match self.code & 0x01800000 {
            0x00800000 => AddrLdmStm::Ia,
            0x01800000 => AddrLdmStm::Ib,
            0x00000000 => AddrLdmStm::Da,
            0x01000000 => AddrLdmStm::Db,
            _ => unreachable!(),
        }
    }
    /// addr_coproc: Load and Store Coprocessor
    pub const fn modifier_addr_coproc(&self) -> AddrCoproc {
        if (self.code & 0x01200000) == 0x01000000 {
            AddrCoproc::Imm
        } else if (self.code & 0x01200000) == 0x01200000 {
            AddrCoproc::ImmPre
        } else if (self.code & 0x01200000) == 0x00200000 {
            AddrCoproc::ImmPost
        } else if (self.code & 0x01200000) == 0x00000000 {
            AddrCoproc::Unidx
        } else {
            unreachable!()
        }
    }
}
/// cond: Condition code
pub enum Cond {
    /// eq: Equal
    Eq,
    /// ne: Not equal
    Ne,
    /// hs: Unsigned higher or same
    Hs,
    /// lo: Unsigned lower
    Lo,
    /// mi: Minus/negative
    Mi,
    /// pl: Plus/positive or zero
    Pl,
    /// vs: Overflow
    Vs,
    /// vc: No overflow
    Vc,
    /// hi: Unsigned higher
    Hi,
    /// ls: Unsigned lower or same
    Ls,
    /// ge: Signed greater than or equal
    Ge,
    /// lt: Signed less than
    Lt,
    /// gt: Signed greater than
    Gt,
    /// le: Signed less than or equal
    Le,
    /// al: Always
    Al,
}
/// addr_data: Data-processing operands
pub enum AddrData {
    /// imm: Immediate
    Imm,
    /// reg: Register
    Reg,
    /// lsl_imm: Logical shift left by immediate
    LslImm,
    /// lsl_reg: Logical shift left by register
    LslReg,
    /// lsr_imm: Logical shift right by immediate
    LsrImm,
    /// lsr_reg: Logical shift right by register
    LsrReg,
    /// asr_imm: Arithmetic shift right by immediate
    AsrImm,
    /// asr_reg: Arithmetic shift right by register
    AsrReg,
    /// ror_imm: Rotate right by immediate
    RorImm,
    /// ror_reg: Rotate right by register
    RorReg,
    /// rrx: Rotate right with extend
    Rrx,
}
/// addr_ldr_str: Load and Store Word or Unsigned Byte
pub enum AddrLdrStr {
    /// imm: Immediate offset
    Imm,
    /// reg: Register offset
    Reg,
    /// scl: Scaled register offset
    Scl,
    /// imm_pre: Immediate pre-indexed
    ImmPre,
    /// reg_pre: Register pre-indexed
    RegPre,
    /// scl_pre: Scaled register pre-indexed
    SclPre,
    /// imm_post: Immediate post-indexed
    ImmPost,
    /// reg_post: Register post-indexed
    RegPost,
    /// scl_post: Scaled register post-indexed
    SclPost,
}
/// addr_misc_ldr_str: Miscellaneous Loads and Stores
pub enum AddrMiscLdrStr {
    /// imm: Immediate offset
    Imm,
    /// reg: Register offset
    Reg,
    /// imm_pre: Immediate pre-indexed
    ImmPre,
    /// reg_pre: Register pre-indexed
    RegPre,
    /// imm_post: Immediate post-indexed
    ImmPost,
    /// reg_post: Register post-indexed
    RegPost,
}
/// addr_ldm_stm: Load and Store Multiple
pub enum AddrLdmStm {
    /// ia: Increment After
    Ia,
    /// ib: Increment Before
    Ib,
    /// da: Decrement After
    Da,
    /// db: Decrement Before
    Db,
}
/// addr_coproc: Load and Store Coprocessor
pub enum AddrCoproc {
    /// imm: Immediate offset
    Imm,
    /// imm_pre: Immediate pre-indexed
    ImmPre,
    /// imm_post: Immediate post-indexed
    ImmPost,
    /// unidx: Unindexed
    Unidx,
}
fn bucket_index(code: u32) -> usize {
    let mut index = 0;
    index |= (code & 0x00000010) >> 4;
    index |= (code & 0x00700000) >> 19;
    index |= (code & 0x01000000) >> 20;
    index |= (code & 0x04000000) >> 21;
    index.try_into().unwrap()
}
