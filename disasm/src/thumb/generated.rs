#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused)]
#![allow(clippy::double_parens, clippy::unnecessary_cast)]
// Generated by armv5te-generator. Do not edit!
use crate::{args::*, thumb::disasm::{Ins, ParsedIns}};
/// These are the mnemonics of each opcode. Some mnemonics are duplicated due to them having multiple formats.
static OPCODE_MNEMONICS: [&str; 65] = [
    "adc",
    "add",
    "add",
    "add",
    "add",
    "add",
    "add",
    "add",
    "and",
    "asr",
    "asr",
    "b",
    "b",
    "bic",
    "bkpt",
    "bl",
    "bl",
    "blx",
    "blx",
    "bx",
    "cmn",
    "cmp",
    "cmp",
    "cmp",
    "eor",
    "ldmia",
    "ldr",
    "ldr",
    "ldr",
    "ldr",
    "ldrb",
    "ldrb",
    "ldrh",
    "ldrh",
    "ldrsb",
    "ldrsh",
    "lsl",
    "lsl",
    "lsr",
    "lsr",
    "mov",
    "mov",
    "mov",
    "mul",
    "mvn",
    "neg",
    "orr",
    "pop",
    "push",
    "ror",
    "sbc",
    "stmia",
    "str",
    "str",
    "str",
    "strb",
    "strb",
    "strh",
    "strh",
    "sub",
    "sub",
    "sub",
    "sub",
    "swi",
    "tst",
];
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
#[non_exhaustive]
pub enum Opcode {
    /// Illegal or unknown
    #[default]
    Illegal = u8::MAX,
    /// ADC: Add with Carry
    Adc = 0,
    /// ADD: Add 3-bit immediate
    Add3 = 1,
    /// ADD: Add 8-bit immediate
    Add8 = 2,
    /// ADD: Add register
    AddR = 3,
    /// ADD: Add high register
    AddHr = 4,
    /// ADD: Add PC-relative address
    AddPc = 5,
    /// ADD: Add SP-relative address
    AddSp = 6,
    /// ADD: Add 7-bit immediate multiple of 4 to SP
    AddSp7 = 7,
    /// AND: Bitwise AND
    And = 8,
    /// ASR: Arithmetic Shift Right by 5-bit immediate
    AsrI = 9,
    /// ASR: Arithmetic Shift Right by register
    AsrR = 10,
    /// B: Branch
    B = 11,
    /// B: Branch (unconditional, long)
    BLong = 12,
    /// BIC: Bit Clear
    Bic = 13,
    /// BKPT: Breakpoint
    Bkpt = 14,
    /// BL: Branch and Link (high part)
    BlH = 15,
    /// BL: Branch and Link (low part)
    Bl = 16,
    /// BLX: Branch and Link and Exchange to ARM (low part, immediate target)
    BlxI = 17,
    /// BLX: Branch and Link and Exchange to ARM (register target)
    BlxR = 18,
    /// BX: Branch and Exchange
    BxR = 19,
    /// CMN: Compare Negative
    Cmn = 20,
    /// CMP: Compare with immediate
    CmpI = 21,
    /// CMP: Compare with register
    CmpR = 22,
    /// CMP: Compare with high register
    CmpHr = 23,
    /// EOR: Exclusive OR
    Eor = 24,
    /// LDMIA: Load Multiple Increment After
    Ldmia = 25,
    /// LDR: Load Register with immediate offset
    LdrI = 26,
    /// LDR: Load Register with register offset
    LdrR = 27,
    /// LDR: Load Register with PC-relative address
    LdrPc = 28,
    /// LDR: Load Register with SP-relative address
    LdrSp = 29,
    /// LDRB: Load Register Byte with immediate offset
    LdrbI = 30,
    /// LDRB: Load Register Byte with register offset
    LdrbR = 31,
    /// LDRH: Load Register Halfword with immediate offset
    LdrhI = 32,
    /// LDRH: Load Register Halfword with register offset
    LdrhR = 33,
    /// LDRSB: Load Register Signed Byte
    Ldrsb = 34,
    /// LDRSH: Load Register Signed Halfword
    Ldrsh = 35,
    /// LSL: Logical Shift Left by 5-bit immediate
    LslI = 36,
    /// LSL: Logical Shift Left by register
    LslR = 37,
    /// LSR: Logical Shift Right by 5-bit immediate
    LsrI = 38,
    /// LSR: Logical Shift Right by register
    LsrR = 39,
    /// MOV: Move immediate
    MovI = 40,
    /// MOV: Move register
    MovR = 41,
    /// MOV: Move high register
    MovHr = 42,
    /// MUL: Multiply
    Mul = 43,
    /// MVN: Move Negative
    Mvn = 44,
    /// NEG: Negate
    Neg = 45,
    /// ORR: Bitwise OR
    Orr = 46,
    /// POP: Pop multiple registers
    Pop = 47,
    /// PUSH: Push multiple registers
    Push = 48,
    /// ROR: Rotate Right
    Ror = 49,
    /// SBC: Subtract with Carry
    Sbc = 50,
    /// STMIA: Store Multiple Increment After
    Stmia = 51,
    /// STR: Store Register with immediate offset
    StrI = 52,
    /// STR: Store Register with register offset
    StrR = 53,
    /// STR: Store Register with SP-relative address
    StrSp = 54,
    /// STRB: Store Register Byte with immediate offset
    StrbI = 55,
    /// STRB: Store Register Byte with register offset
    StrbR = 56,
    /// STRH: Store Register Halfword with immediate offset
    StrhI = 57,
    /// STRH: Store Register Halfword with register offset
    StrhR = 58,
    /// SUB: Subtract 3-bit immediate
    Sub3 = 59,
    /// SUB: Subtract 8-bit immediate
    Sub8 = 60,
    /// SUB: Subtract register
    SubR = 61,
    /// SUB: Subtract 7-bit immediate multiple of 4 from SP
    SubSp7 = 62,
    /// SWI: Software Interrupt
    Swi = 63,
    /// TST: Test
    Tst = 64,
}
impl Opcode {
    #[inline]
    pub fn find(code: u32) -> Self {
        if (code & 0x00001000) == 0x00000000 {
            if (code & 0x00000400) == 0x00000400 {
                if (code & 0x00000800) == 0x00000000 {
                    if (code & 0x00002000) == 0x00000000 {
                        if (code & 0x00000100) == 0x00000000 {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000000 {
                                        return Opcode::LslI;
                                    }
                                } else if (code & 0x0000f800) == 0x00008000 {
                                    return Opcode::StrhI;
                                }
                            } else if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f800) == 0x0000c000 {
                                    return Opcode::Stmia;
                                }
                            } else if (code & 0x00000200) == 0x00000000 {
                                if (code & 0x0000ff00) == 0x00004400 {
                                    return Opcode::AddHr;
                                }
                            } else if (code & 0x0000ff00) == 0x00004600 {
                                return Opcode::MovHr;
                            }
                        } else if (code & 0x00000200) == 0x00000000 {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000000 {
                                        return Opcode::LslI;
                                    }
                                } else if (code & 0x0000f800) == 0x00008000 {
                                    return Opcode::StrhI;
                                }
                            } else if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000ff00) == 0x00004500 {
                                    return Opcode::CmpHr;
                                }
                            } else if (code & 0x0000f800) == 0x0000c000 {
                                return Opcode::Stmia;
                            }
                        } else if (code & 0x00004000) == 0x00000000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00000000 {
                                    return Opcode::LslI;
                                }
                            } else if (code & 0x0000f800) == 0x00008000 {
                                return Opcode::StrhI;
                            }
                        } else if (code & 0x00008000) == 0x00008000 {
                            if (code & 0x0000f800) == 0x0000c000 {
                                return Opcode::Stmia;
                            }
                        } else if (code & 0x00000080) == 0x00000000 {
                            if (code & 0x0000ff87) == 0x00004700 {
                                return Opcode::BxR;
                            }
                        } else if (code & 0x0000ff87) == 0x00004780 {
                            return Opcode::BlxR;
                        }
                    } else if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00002000 {
                                return Opcode::MovI;
                            }
                        } else if (code & 0x0000f800) == 0x0000a000 {
                            return Opcode::AddPc;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00006000 {
                            return Opcode::StrI;
                        }
                    } else if (code & 0x0000f800) == 0x0000e000 {
                        return Opcode::BLong;
                    }
                } else if (code & 0x00002000) == 0x00000000 {
                    if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00000800 {
                                return Opcode::LsrI;
                            }
                        } else if (code & 0x0000f800) == 0x00008800 {
                            return Opcode::LdrhI;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00004800 {
                            return Opcode::LdrPc;
                        }
                    } else if (code & 0x0000f800) == 0x0000c800 {
                        return Opcode::Ldmia;
                    }
                } else if (code & 0x00004000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00002800 {
                            return Opcode::CmpI;
                        }
                    } else if (code & 0x0000f800) == 0x0000a800 {
                        return Opcode::AddSp;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00006800 {
                        return Opcode::LdrI;
                    }
                } else if (code & 0x0000f800) == 0x0000e800 {
                    return Opcode::BlxI;
                }
            } else if (code & 0x00000040) == 0x00000000 {
                if (code & 0x00000800) == 0x00000000 {
                    if (code & 0x00000080) == 0x00000000 {
                        if (code & 0x00002000) == 0x00000000 {
                            if (code & 0x00000100) == 0x00000000 {
                                if (code & 0x00004000) == 0x00000000 {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00000000 {
                                            return Opcode::LslI;
                                        }
                                    } else if (code & 0x0000f800) == 0x00008000 {
                                        return Opcode::StrhI;
                                    }
                                } else if (code & 0x00008000) == 0x00008000 {
                                    if (code & 0x0000f800) == 0x0000c000 {
                                        return Opcode::Stmia;
                                    }
                                } else if (code & 0x00000200) == 0x00000000 {
                                    if (code & 0x0000ffc0) == 0x00004000 {
                                        return Opcode::And;
                                    }
                                } else if (code & 0x0000ffc0) == 0x00004200 {
                                    return Opcode::Tst;
                                }
                            } else if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000000 {
                                        return Opcode::LslI;
                                    }
                                } else if (code & 0x0000f800) == 0x00008000 {
                                    return Opcode::StrhI;
                                }
                            } else if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f800) == 0x0000c000 {
                                    return Opcode::Stmia;
                                }
                            } else if (code & 0x00000200) == 0x00000000 {
                                if (code & 0x0000ffc0) == 0x00004100 {
                                    return Opcode::AsrR;
                                }
                            } else if (code & 0x0000ffc0) == 0x00004300 {
                                return Opcode::Orr;
                            }
                        } else if (code & 0x00004000) == 0x00000000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00002000 {
                                    return Opcode::MovI;
                                }
                            } else if (code & 0x0000f800) == 0x0000a000 {
                                return Opcode::AddPc;
                            }
                        } else if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00006000 {
                                return Opcode::StrI;
                            }
                        } else if (code & 0x0000f800) == 0x0000e000 {
                            return Opcode::BLong;
                        }
                    } else if (code & 0x00002000) == 0x00000000 {
                        if (code & 0x00000100) == 0x00000000 {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000000 {
                                        return Opcode::LslI;
                                    }
                                } else if (code & 0x0000f800) == 0x00008000 {
                                    return Opcode::StrhI;
                                }
                            } else if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f800) == 0x0000c000 {
                                    return Opcode::Stmia;
                                }
                            } else if (code & 0x00000200) == 0x00000000 {
                                if (code & 0x0000ffc0) == 0x00004080 {
                                    return Opcode::LslR;
                                }
                            } else if (code & 0x0000ffc0) == 0x00004280 {
                                return Opcode::CmpR;
                            }
                        } else if (code & 0x00004000) == 0x00000000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00000000 {
                                    return Opcode::LslI;
                                }
                            } else if (code & 0x0000f800) == 0x00008000 {
                                return Opcode::StrhI;
                            }
                        } else if (code & 0x00008000) == 0x00008000 {
                            if (code & 0x0000f800) == 0x0000c000 {
                                return Opcode::Stmia;
                            }
                        } else if (code & 0x00000200) == 0x00000000 {
                            if (code & 0x0000ffc0) == 0x00004180 {
                                return Opcode::Sbc;
                            }
                        } else if (code & 0x0000ffc0) == 0x00004380 {
                            return Opcode::Bic;
                        }
                    } else if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00002000 {
                                return Opcode::MovI;
                            }
                        } else if (code & 0x0000f800) == 0x0000a000 {
                            return Opcode::AddPc;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00006000 {
                            return Opcode::StrI;
                        }
                    } else if (code & 0x0000f800) == 0x0000e000 {
                        return Opcode::BLong;
                    }
                } else if (code & 0x00002000) == 0x00000000 {
                    if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00000800 {
                                return Opcode::LsrI;
                            }
                        } else if (code & 0x0000f800) == 0x00008800 {
                            return Opcode::LdrhI;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00004800 {
                            return Opcode::LdrPc;
                        }
                    } else if (code & 0x0000f800) == 0x0000c800 {
                        return Opcode::Ldmia;
                    }
                } else if (code & 0x00004000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00002800 {
                            return Opcode::CmpI;
                        }
                    } else if (code & 0x0000f800) == 0x0000a800 {
                        return Opcode::AddSp;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00006800 {
                        return Opcode::LdrI;
                    }
                } else if (code & 0x0000f800) == 0x0000e800 {
                    return Opcode::BlxI;
                }
            } else if (code & 0x00000800) == 0x00000000 {
                if (code & 0x00000080) == 0x00000000 {
                    if (code & 0x00002000) == 0x00000000 {
                        if (code & 0x00000100) == 0x00000000 {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000000 {
                                        return Opcode::LslI;
                                    }
                                } else if (code & 0x0000f800) == 0x00008000 {
                                    return Opcode::StrhI;
                                }
                            } else if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f800) == 0x0000c000 {
                                    return Opcode::Stmia;
                                }
                            } else if (code & 0x00000200) == 0x00000000 {
                                if (code & 0x0000ffc0) == 0x00004040 {
                                    return Opcode::Eor;
                                }
                            } else if (code & 0x0000ffc0) == 0x00004240 {
                                return Opcode::Neg;
                            }
                        } else if (code & 0x00004000) == 0x00000000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00000000 {
                                    return Opcode::LslI;
                                }
                            } else if (code & 0x0000f800) == 0x00008000 {
                                return Opcode::StrhI;
                            }
                        } else if (code & 0x00008000) == 0x00008000 {
                            if (code & 0x0000f800) == 0x0000c000 {
                                return Opcode::Stmia;
                            }
                        } else if (code & 0x00000200) == 0x00000000 {
                            if (code & 0x0000ffc0) == 0x00004140 {
                                return Opcode::Adc;
                            }
                        } else if (code & 0x0000ffc0) == 0x00004340 {
                            return Opcode::Mul;
                        }
                    } else if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00002000 {
                                return Opcode::MovI;
                            }
                        } else if (code & 0x0000f800) == 0x0000a000 {
                            return Opcode::AddPc;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00006000 {
                            return Opcode::StrI;
                        }
                    } else if (code & 0x0000f800) == 0x0000e000 {
                        return Opcode::BLong;
                    }
                } else if (code & 0x00002000) == 0x00000000 {
                    if (code & 0x00000100) == 0x00000000 {
                        if (code & 0x00004000) == 0x00000000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00000000 {
                                    return Opcode::LslI;
                                }
                            } else if (code & 0x0000f800) == 0x00008000 {
                                return Opcode::StrhI;
                            }
                        } else if (code & 0x00008000) == 0x00008000 {
                            if (code & 0x0000f800) == 0x0000c000 {
                                return Opcode::Stmia;
                            }
                        } else if (code & 0x00000200) == 0x00000000 {
                            if (code & 0x0000ffc0) == 0x000040c0 {
                                return Opcode::LsrR;
                            }
                        } else if (code & 0x0000ffc0) == 0x000042c0 {
                            return Opcode::Cmn;
                        }
                    } else if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00000000 {
                                return Opcode::LslI;
                            }
                        } else if (code & 0x0000f800) == 0x00008000 {
                            return Opcode::StrhI;
                        }
                    } else if (code & 0x00008000) == 0x00008000 {
                        if (code & 0x0000f800) == 0x0000c000 {
                            return Opcode::Stmia;
                        }
                    } else if (code & 0x00000200) == 0x00000000 {
                        if (code & 0x0000ffc0) == 0x000041c0 {
                            return Opcode::Ror;
                        }
                    } else if (code & 0x0000ffc0) == 0x000043c0 {
                        return Opcode::Mvn;
                    }
                } else if (code & 0x00004000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00002000 {
                            return Opcode::MovI;
                        }
                    } else if (code & 0x0000f800) == 0x0000a000 {
                        return Opcode::AddPc;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00006000 {
                        return Opcode::StrI;
                    }
                } else if (code & 0x0000f800) == 0x0000e000 {
                    return Opcode::BLong;
                }
            } else if (code & 0x00002000) == 0x00000000 {
                if (code & 0x00004000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00000800 {
                            return Opcode::LsrI;
                        }
                    } else if (code & 0x0000f800) == 0x00008800 {
                        return Opcode::LdrhI;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00004800 {
                        return Opcode::LdrPc;
                    }
                } else if (code & 0x0000f800) == 0x0000c800 {
                    return Opcode::Ldmia;
                }
            } else if (code & 0x00004000) == 0x00000000 {
                if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00002800 {
                        return Opcode::CmpI;
                    }
                } else if (code & 0x0000f800) == 0x0000a800 {
                    return Opcode::AddSp;
                }
            } else if (code & 0x00008000) == 0x00000000 {
                if (code & 0x0000f800) == 0x00006800 {
                    return Opcode::LdrI;
                }
            } else if (code & 0x0000f800) == 0x0000e800 {
                return Opcode::BlxI;
            }
        } else if (code & 0x00004000) == 0x00000000 {
            if (code & 0x00000200) == 0x00000200 {
                if (code & 0x00000800) == 0x00000000 {
                    if (code & 0x00002000) == 0x00002000 {
                        if (code & 0x0000f800) == 0x00003000 {
                            return Opcode::Add8;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00001000 {
                            return Opcode::AsrI;
                        }
                    } else if (code & 0x0000f800) == 0x00009000 {
                        return Opcode::StrSp;
                    }
                } else if (code & 0x00000400) == 0x00000000 {
                    if (code & 0x00002000) == 0x00002000 {
                        if (code & 0x0000f800) == 0x00003800 {
                            return Opcode::Sub8;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000fe00) == 0x00001a00 {
                            return Opcode::SubR;
                        }
                    } else if (code & 0x0000f800) == 0x00009800 {
                        return Opcode::LdrSp;
                    }
                } else if (code & 0x00002000) == 0x00002000 {
                    if (code & 0x0000f800) == 0x00003800 {
                        return Opcode::Sub8;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000fe00) == 0x00001e00 {
                        return Opcode::Sub3;
                    }
                } else if (code & 0x0000f800) == 0x00009800 {
                    return Opcode::LdrSp;
                }
            } else if (code & 0x00000800) == 0x00000000 {
                if (code & 0x00000400) == 0x00000400 {
                    if (code & 0x00002000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00001000 {
                                return Opcode::AsrI;
                            }
                        } else if (code & 0x0000f800) == 0x00009000 {
                            return Opcode::StrSp;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00003000 {
                            return Opcode::Add8;
                        }
                    } else if (code & 0x0000fe00) == 0x0000b400 {
                        return Opcode::Push;
                    }
                } else if (code & 0x00002000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00001000 {
                            return Opcode::AsrI;
                        }
                    } else if (code & 0x0000f800) == 0x00009000 {
                        return Opcode::StrSp;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00003000 {
                        return Opcode::Add8;
                    }
                } else if (code & 0x00000080) == 0x00000000 {
                    if (code & 0x0000ff80) == 0x0000b000 {
                        return Opcode::AddSp7;
                    }
                } else if (code & 0x0000ff80) == 0x0000b080 {
                    return Opcode::SubSp7;
                }
            } else if (code & 0x00000400) == 0x00000000 {
                if (code & 0x00002000) == 0x00002000 {
                    if (code & 0x0000f800) == 0x00003800 {
                        return Opcode::Sub8;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000fe00) == 0x00001800 {
                        return Opcode::AddR;
                    }
                } else if (code & 0x0000f800) == 0x00009800 {
                    return Opcode::LdrSp;
                }
            } else if (code & 0x00002000) == 0x00002000 {
                if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00003800 {
                        return Opcode::Sub8;
                    }
                } else if (code & 0x0000fe00) == 0x0000bc00 {
                    return Opcode::Pop;
                }
            } else if (code & 0x00008000) == 0x00008000 {
                if (code & 0x0000f800) == 0x00009800 {
                    return Opcode::LdrSp;
                }
            } else if (code & 0x0000ffc0) == 0x00001c00 {
                return Opcode::MovR;
            } else if (code & 0x0000fe00) == 0x00001c00 {
                return Opcode::Add3;
            }
        } else if (code & 0x00000800) == 0x00000000 {
            if (code & 0x00000200) == 0x00000000 {
                if (code & 0x00002000) == 0x00002000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00007000 {
                            return Opcode::StrbI;
                        }
                    } else if (code & 0x0000f800) == 0x0000f000 {
                        return Opcode::BlH;
                    }
                } else if (code & 0x00008000) == 0x00008000 {
                    if (code & 0x0000f000) == 0x0000d000 {
                        return Opcode::B;
                    }
                } else if (code & 0x00000400) == 0x00000000 {
                    if (code & 0x0000fe00) == 0x00005000 {
                        return Opcode::StrR;
                    }
                } else if (code & 0x0000fe00) == 0x00005400 {
                    return Opcode::StrbR;
                }
            } else if (code & 0x00002000) == 0x00002000 {
                if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00007000 {
                        return Opcode::StrbI;
                    }
                } else if (code & 0x0000f800) == 0x0000f000 {
                    return Opcode::BlH;
                }
            } else if (code & 0x00008000) == 0x00008000 {
                if (code & 0x0000f000) == 0x0000d000 {
                    return Opcode::B;
                }
            } else if (code & 0x00000400) == 0x00000000 {
                if (code & 0x0000fe00) == 0x00005200 {
                    return Opcode::StrhR;
                }
            } else if (code & 0x0000fe00) == 0x00005600 {
                return Opcode::Ldrsb;
            }
        } else if (code & 0x00008000) == 0x00008000 {
            if (code & 0x00000100) == 0x00000000 {
                if (code & 0x00002000) == 0x00002000 {
                    if (code & 0x0000f800) == 0x0000f800 {
                        return Opcode::Bl;
                    }
                } else if (code & 0x0000ff00) == 0x0000de00 {
                    return Opcode::Bkpt;
                } else if (code & 0x0000f000) == 0x0000d000 {
                    return Opcode::B;
                }
            } else if (code & 0x00002000) == 0x00002000 {
                if (code & 0x0000f800) == 0x0000f800 {
                    return Opcode::Bl;
                }
            } else if (code & 0x0000ff00) == 0x0000df00 {
                return Opcode::Swi;
            } else if (code & 0x0000f000) == 0x0000d000 {
                return Opcode::B;
            }
        } else if (code & 0x00000200) == 0x00000000 {
            if (code & 0x00002000) == 0x00002000 {
                if (code & 0x0000f800) == 0x00007800 {
                    return Opcode::LdrbI;
                }
            } else if (code & 0x00000400) == 0x00000000 {
                if (code & 0x0000fe00) == 0x00005800 {
                    return Opcode::LdrR;
                }
            } else if (code & 0x0000fe00) == 0x00005c00 {
                return Opcode::LdrbR;
            }
        } else if (code & 0x00002000) == 0x00002000 {
            if (code & 0x0000f800) == 0x00007800 {
                return Opcode::LdrbI;
            }
        } else if (code & 0x00000400) == 0x00000000 {
            if (code & 0x0000fe00) == 0x00005a00 {
                return Opcode::LdrhR;
            }
        } else if (code & 0x0000fe00) == 0x00005e00 {
            return Opcode::Ldrsh;
        }
        Opcode::Illegal
    }
    pub fn mnemonic(self) -> &'static str {
        OPCODE_MNEMONICS[self as usize]
    }
    pub fn count() -> usize {
        65
    }
}
impl Ins {
    /// Rd_0: Destination register
    #[inline(always)]
    pub fn field_rd_0(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse((self.code & 0x00000007)),
            writeback: false,
        }
    }
    /// Rd_8: Destination register
    #[inline(always)]
    pub fn field_rd_8(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 8) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rd_H1: Destination register
    #[inline(always)]
    pub fn field_rd_h1(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(
                (self.code & 0x00000007) | ((self.code >> 7) & 0x00000001) << 3,
            ),
            writeback: false,
        }
    }
    /// Rn_0: First source operand register
    #[inline(always)]
    pub fn field_rn_0(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse((self.code & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_3: First source operand register
    #[inline(always)]
    pub fn field_rn_3(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_3_deref: Base register
    #[inline(always)]
    pub fn field_rn_3_deref(&self) -> Reg {
        Reg {
            deref: true,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_8: First source operand register
    #[inline(always)]
    pub fn field_rn_8(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 8) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_8_wb: First source operand register
    #[inline(always)]
    pub fn field_rn_8_wb(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 8) & 0x00000007)),
            writeback: true,
        }
    }
    /// Rn_H1: First source operand register
    #[inline(always)]
    pub fn field_rn_h1(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(
                (self.code & 0x00000007) | ((self.code >> 7) & 0x00000001) << 3,
            ),
            writeback: false,
        }
    }
    /// Rm_3: Second source operand register
    #[inline(always)]
    pub fn field_rm_3(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rm_6: Second source operand register
    #[inline(always)]
    pub fn field_rm_6(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 6) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rm_6_offset: Offset register
    #[inline(always)]
    pub fn field_rm_6_offset(&self) -> OffsetReg {
        OffsetReg {
            add: true,
            post_indexed: false,
            reg: Register::parse(((self.code >> 6) & 0x00000007)),
        }
    }
    /// Rm_H2: Second source operand register
    #[inline(always)]
    pub fn field_rm_h2(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x0000000f)),
            writeback: false,
        }
    }
    /// Rs: Register containing shift offset
    #[inline(always)]
    pub fn field_rs(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// pc: Program counter
    #[inline(always)]
    pub fn field_pc(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(15),
            writeback: false,
        }
    }
    /// pc_deref: Program counter as base register
    #[inline(always)]
    pub fn field_pc_deref(&self) -> Reg {
        Reg {
            deref: true,
            reg: Register::parse(15),
            writeback: false,
        }
    }
    /// sp: Stack pointer
    #[inline(always)]
    pub fn field_sp(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(13),
            writeback: false,
        }
    }
    /// sp_deref: Stack pointer as base register
    #[inline(always)]
    pub fn field_sp_deref(&self) -> Reg {
        Reg {
            deref: true,
            reg: Register::parse(13),
            writeback: false,
        }
    }
    /// registers: List of general-purpose registers
    #[inline(always)]
    pub fn field_registers(&self) -> RegList {
        RegList {
            regs: (self.code & 0x000000ff),
            user_mode: false,
        }
    }
    /// registers_pc: List of general-purpose registers, including PC
    #[inline(always)]
    pub fn field_registers_pc(&self) -> RegList {
        RegList {
            regs: (self.code & 0x000000ff) | ((self.code >> 8) & 0x00000001) << 15,
            user_mode: false,
        }
    }
    /// immed_3: 3-bit immediate
    #[inline(always)]
    pub fn field_immed_3(&self) -> u32 {
        ((self.code >> 6) & 0x00000007)
    }
    /// immed_8: 8-bit immediate
    #[inline(always)]
    pub fn field_immed_8(&self) -> u32 {
        (self.code & 0x000000ff)
    }
    /// rel_immed_7: Address-relative 7-bit immediate
    #[inline(always)]
    pub fn field_rel_immed_7(&self) -> u32 {
        (self.code & 0x0000007f) << 2
    }
    /// rel_immed_8: Address-relative 8-bit immediate
    #[inline(always)]
    pub fn field_rel_immed_8(&self) -> u32 {
        (self.code & 0x000000ff) << 2
    }
    /// left_shift_imm: 5-bit left shift offset
    #[inline(always)]
    pub fn field_left_shift_imm(&self) -> u32 {
        ((self.code >> 6) & 0x0000001f)
    }
    /// right_shift_imm: 5-bit right shift offset
    #[inline(always)]
    pub fn field_right_shift_imm(&self) -> u32 {
        {
            let value = ((self.code >> 6) & 0x0000001f);
            match 1 {
                1 | 2 => if value == 0 { 32 } else { value }
                _ => value,
            }
        }
    }
    /// branch_offset_8: 9-bit signed B/BL target offset
    #[inline(always)]
    pub fn field_branch_offset_8(&self) -> i32 {
        (((self.code & 0x000000ff) << 1) + 4) as i32
    }
    /// branch_offset_11: 12-bit signed B target offset
    #[inline(always)]
    pub fn field_branch_offset_11(&self) -> i32 {
        (((self.code & 0x000007ff) << 1) + 4) as i32
    }
    /// high_branch_offset_11: 23-bit signed BL/BLX target offset (high part)
    #[inline(always)]
    pub fn field_high_branch_offset_11(&self) -> i32 {
        (((self.code & 0x000007ff) << 12) + 4) as i32
    }
    /// low_branch_offset_11: 23-bit signed BL target offset (low part)
    #[inline(always)]
    pub fn field_low_branch_offset_11(&self) -> u32 {
        (self.code & 0x000007ff) << 1
    }
    /// low_blx_offset_11: 23-bit signed BLX target offset (low part)
    #[inline(always)]
    pub fn field_low_blx_offset_11(&self) -> u32 {
        (self.code & 0x000007ff) << 1 & !3
    }
    /// offset_5: 7-bit immediate offset
    #[inline(always)]
    pub fn field_offset_5(&self) -> OffsetImm {
        OffsetImm {
            post_indexed: false,
            value: (((self.code >> 6) & 0x0000001f) << 2) as i32,
        }
    }
    /// cond: Condition code
    #[inline(always)]
    pub const fn modifier_cond(&self) -> Cond {
        match self.code & 0x00000f00 {
            0x00000000 => Cond::Eq,
            0x00000100 => Cond::Ne,
            0x00000200 => Cond::Hs,
            0x00000300 => Cond::Lo,
            0x00000400 => Cond::Mi,
            0x00000500 => Cond::Pl,
            0x00000600 => Cond::Vs,
            0x00000700 => Cond::Vc,
            0x00000800 => Cond::Hi,
            0x00000900 => Cond::Ls,
            0x00000a00 => Cond::Ge,
            0x00000b00 => Cond::Lt,
            0x00000c00 => Cond::Gt,
            0x00000d00 => Cond::Le,
            0x00000e00 => Cond::Al,
            _ => Cond::Illegal,
        }
    }
}
/// cond: Condition code
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Cond {
    Illegal,
    /// eq: Equal
    Eq,
    /// ne: Not equal
    Ne,
    /// hs: Unsigned higher or same
    Hs,
    /// lo: Unsigned lower
    Lo,
    /// mi: Minus/negative
    Mi,
    /// pl: Plus/positive or zero
    Pl,
    /// vs: Overflow
    Vs,
    /// vc: No overflow
    Vc,
    /// hi: Unsigned higher
    Hi,
    /// ls: Unsigned lower or same
    Ls,
    /// ge: Signed greater than or equal
    Ge,
    /// lt: Signed less than
    Lt,
    /// gt: Signed greater than
    Gt,
    /// le: Signed less than or equal
    Le,
    /// al: Always
    Al,
}
fn parse_adc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "adc",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_3(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::UImm(ins.field_immed_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_8(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::Reg(ins.field_rm_6()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_hr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_h1()),
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_pc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_pc()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_sp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_sp()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_sp7(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_sp()),
            Argument::UImm(ins.field_rel_immed_7()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_and(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "and",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_asr_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "asr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::UImm(ins.field_right_shift_imm()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_asr_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "asr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rs()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_b(out: &mut ParsedIns, ins: Ins) {
    *out = match ins.modifier_cond() {
        Cond::Eq => {
            ParsedIns {
                mnemonic: "beq",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Ne => {
            ParsedIns {
                mnemonic: "bne",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Hs => {
            ParsedIns {
                mnemonic: "bhs",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Lo => {
            ParsedIns {
                mnemonic: "blo",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Mi => {
            ParsedIns {
                mnemonic: "bmi",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Pl => {
            ParsedIns {
                mnemonic: "bpl",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Vs => {
            ParsedIns {
                mnemonic: "bvs",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Vc => {
            ParsedIns {
                mnemonic: "bvc",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Hi => {
            ParsedIns {
                mnemonic: "bhi",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Ls => {
            ParsedIns {
                mnemonic: "bls",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Ge => {
            ParsedIns {
                mnemonic: "bge",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Lt => {
            ParsedIns {
                mnemonic: "blt",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Gt => {
            ParsedIns {
                mnemonic: "bgt",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Le => {
            ParsedIns {
                mnemonic: "ble",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Al => {
            ParsedIns {
                mnemonic: "b",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        _ => {
            ParsedIns {
                mnemonic: "<illegal>",
                args: [
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
    };
}
fn parse_b_long(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "b",
        args: [
            Argument::SImm(ins.field_branch_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bic(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "bic",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bkpt(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "bkpt",
        args: [
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bl_h(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "bl",
        args: [
            Argument::SImm(ins.field_high_branch_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bl(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "bl",
        args: [
            Argument::UImm(ins.field_low_branch_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_blx_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "blx",
        args: [
            Argument::UImm(ins.field_low_blx_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_blx_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "blx",
        args: [
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bx_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "bx",
        args: [
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmn(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmn",
        args: [
            Argument::Reg(ins.field_rn_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmp_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::Reg(ins.field_rn_8()),
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmp_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::Reg(ins.field_rn_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmp_hr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::Reg(ins.field_rn_h1()),
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_eor(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "eor",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldmia(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldmia",
        args: [
            Argument::Reg(ins.field_rn_8_wb()),
            Argument::RegList(ins.field_registers()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_pc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_pc_deref()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_sp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_sp_deref()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrb_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldrb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrb_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldrb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrh_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldrh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrh_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldrh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrsb(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldrsb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrsh(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ldrsh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_lsl_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lsl",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::UImm(ins.field_left_shift_imm()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_lsl_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lsl",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rs()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_lsr_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lsr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::UImm(ins.field_right_shift_imm()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_lsr_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "lsr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rs()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_mov_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mov",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_mov_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mov",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_mov_hr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mov",
        args: [
            Argument::Reg(ins.field_rd_h1()),
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_mul(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mul",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_mvn(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "mvn",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_neg(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "neg",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_orr(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "orr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_pop(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "pop",
        args: [
            Argument::RegList(ins.field_registers_pc()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_push(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "push",
        args: [
            Argument::RegList(ins.field_registers_pc()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ror(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "ror",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rs()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sbc(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sbc",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_stmia(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "stmia",
        args: [
            Argument::Reg(ins.field_rn_8_wb()),
            Argument::RegList(ins.field_registers()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_str_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "str",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_str_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "str",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_str_sp(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "str",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_sp_deref()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strb_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "strb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strb_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "strb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strh_i(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "strh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strh_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "strh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sub_3(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sub",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::UImm(ins.field_immed_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sub_8(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sub",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sub_r(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sub",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::Reg(ins.field_rm_6()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sub_sp7(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "sub",
        args: [
            Argument::Reg(ins.field_sp()),
            Argument::UImm(ins.field_rel_immed_7()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_swi(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "swi",
        args: [
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_tst(out: &mut ParsedIns, ins: Ins) {
    *out = ParsedIns {
        mnemonic: "tst",
        args: [
            Argument::Reg(ins.field_rn_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
type MnemonicParser = fn(&mut ParsedIns, Ins);
static MNEMONIC_PARSERS: [MnemonicParser; 65] = [
    parse_adc,
    parse_add_3,
    parse_add_8,
    parse_add_r,
    parse_add_hr,
    parse_add_pc,
    parse_add_sp,
    parse_add_sp7,
    parse_and,
    parse_asr_i,
    parse_asr_r,
    parse_b,
    parse_b_long,
    parse_bic,
    parse_bkpt,
    parse_bl_h,
    parse_bl,
    parse_blx_i,
    parse_blx_r,
    parse_bx_r,
    parse_cmn,
    parse_cmp_i,
    parse_cmp_r,
    parse_cmp_hr,
    parse_eor,
    parse_ldmia,
    parse_ldr_i,
    parse_ldr_r,
    parse_ldr_pc,
    parse_ldr_sp,
    parse_ldrb_i,
    parse_ldrb_r,
    parse_ldrh_i,
    parse_ldrh_r,
    parse_ldrsb,
    parse_ldrsh,
    parse_lsl_i,
    parse_lsl_r,
    parse_lsr_i,
    parse_lsr_r,
    parse_mov_i,
    parse_mov_r,
    parse_mov_hr,
    parse_mul,
    parse_mvn,
    parse_neg,
    parse_orr,
    parse_pop,
    parse_push,
    parse_ror,
    parse_sbc,
    parse_stmia,
    parse_str_i,
    parse_str_r,
    parse_str_sp,
    parse_strb_i,
    parse_strb_r,
    parse_strh_i,
    parse_strh_r,
    parse_sub_3,
    parse_sub_8,
    parse_sub_r,
    parse_sub_sp7,
    parse_swi,
    parse_tst,
];
#[inline]
pub fn parse(out: &mut ParsedIns, ins: Ins) {
    if ins.op != Opcode::Illegal {
        MNEMONIC_PARSERS[ins.op as usize](out, ins);
    } else {
        *out = ParsedIns {
            mnemonic: "<illegal>",
            args: [
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
    }
}
