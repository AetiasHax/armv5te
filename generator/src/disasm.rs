use anyhow::Result;
use proc_macro2::{Literal, TokenStream};
use quote::quote;

use crate::{
    isa::{Isa, Opcode},
    token::HexLiteral,
};

pub fn generate_disasm(isa: &Isa, bucket_bitmask: u32) -> Result<TokenStream> {
    // To improve the search, the opcodes are sorted by bucket index. Read further for more info.
    let sorted_opcodes = sort_opcodes(isa, bucket_bitmask);
    let (opcode_patterns_tokens, opcode_enum_tokens, opcode_names_tokens) = generate_opcode_tokens(&sorted_opcodes);

    // We could use a binary search on sorted_opcodes, but we can do better. We generate a lookup table which maps a bucket
    // index to the range of opcodes in sorted_opcodes with that bucket index.
    let bucket_count = 1 << bucket_bitmask.count_ones();
    let lookup_table = create_lookup_table(bucket_count, sorted_opcodes);
    let lookup_table_tokens = generate_lookup_table_tokens(lookup_table);

    // TODO: Generate field accessors

    // TODO: Generate modifier accessors

    let bucket_count = Literal::u8_unsuffixed(bucket_count);
    Ok(quote! {
        #![cfg_attr(rustfmt, rustfmt_skip)]
        #[comment = " Generated by armv5te-generator. Do not edit!"]
        static LOOKUP_TABLE: [(u8, u8); #bucket_count] = [#lookup_table_tokens];
    })
}

fn generate_lookup_table_tokens(lookup_table: Vec<(u8, u8)>) -> TokenStream {
    let mut lookup_table_tokens = TokenStream::new();
    for entry in lookup_table {
        let start = Literal::u8_unsuffixed(entry.0);
        let end = Literal::u8_unsuffixed(entry.1);
        lookup_table_tokens.extend(quote! { (#start, #end), });
    }
    lookup_table_tokens
}

fn create_lookup_table(bucket_count: u8, sorted_opcodes: Vec<(Opcode, u8)>) -> Vec<(u8, u8)> {
    (0..bucket_count)
        .map(|bucket| {
            let start = sorted_opcodes
                .iter()
                .position(|(_, b)| *b == bucket)
                .map(|p| p.try_into().unwrap())
                .unwrap_or(0);
            let end = sorted_opcodes
                .iter()
                .rev()
                .position(|(_, b)| *b == bucket)
                .map(|p| (sorted_opcodes.len() - p).try_into().unwrap())
                .unwrap_or(0);
            (start, end)
        })
        .collect()
}

fn generate_opcode_tokens(sorted_opcodes: &[(Opcode, u8)]) -> (TokenStream, TokenStream, TokenStream) {
    let mut opcode_patterns_tokens = TokenStream::new();
    let mut opcode_enum_tokens = TokenStream::new();
    let mut opcode_names_tokens = TokenStream::new();
    for (i, (opcode, _)) in sorted_opcodes.iter().enumerate() {
        let bitmask = HexLiteral(opcode.bitmask);
        let pattern = HexLiteral(opcode.pattern);
        opcode_patterns_tokens.extend(quote! { (#bitmask, #pattern), });

        let name = &opcode.name;
        opcode_names_tokens.extend(quote! { #name, });

        let doc = opcode.doc();
        let enum_name = opcode.enum_name();
        let enum_value = Literal::u8_unsuffixed(i.try_into().unwrap());
        opcode_enum_tokens.extend(quote! {
            #[doc = #doc]
            #enum_name = #enum_value
        });
    }
    (opcode_patterns_tokens, opcode_enum_tokens, opcode_names_tokens)
}

fn sort_opcodes(isa: &Isa, bucket_bitmask: u32) -> Vec<(Opcode, u8)> {
    let mut opcodes: Vec<_> = isa
        .opcodes
        .iter()
        .cloned()
        .map(|op| {
            let bucket = op.opcode_bucket(bucket_bitmask);
            (op, bucket.try_into().unwrap())
        })
        .collect();
    opcodes.sort_unstable_by_key(|(_, bucket)| *bucket);
    opcodes
}
